Integración Medusa Backend ↔ Next.js Frontend
Cliente Medusa JS SDK
Configuración del Cliente
typescript// src/lib/medusa/config.ts
export const configMedusa = {
  baseUrl: process.env.NEXT_PUBLIC_MEDUSA_BACKEND_URL!,
  publishableKey: process.env.NEXT_PUBLIC_MEDUSA_PUBLISHABLE_KEY!,
  debug: process.env.NODE_ENV === "development",
} as const

// Validación de variables de entorno
if (!configMedusa.baseUrl) {
  throw new Error("NEXT_PUBLIC_MEDUSA_BACKEND_URL no está definida")
}

if (!configMedusa.publishableKey) {
  throw new Error("NEXT_PUBLIC_MEDUSA_PUBLISHABLE_KEY no está definida")
}
typescript// src/lib/medusa/cliente.ts
import Medusa from "@medusajs/js-sdk"
import { configMedusa } from "./config"

export const clienteMedusa = new Medusa(configMedusa)
Patrón de Servicios Frontend
Servicio de Productos
typescript// src/lib/medusa/productos.ts
import { clienteMedusa } from "./cliente"
import { unstable_cache } from "next/cache"
import type { StoreProduct } from "@medusajs/types"

export async function listarProductos(params?: {
  q?: string
  categoriaId?: string
  limite?: number
  offset?: number
}) {
  const { products, count } = await clienteMedusa.store.product.list({
    q: params?.q,
    category_id: params?.categoriaId ? [params.categoriaId] : undefined,
    limit: params?.limite || 20,
    offset: params?.offset || 0,
  })

  return { productos: products, total: count }
}

// Con caché para productos
export const obtenerProductoPorHandle = unstable_cache(
  async (handle: string): Promise<StoreProduct | null> => {
    const { products } = await clienteMedusa.store.product.list({
      handle,
      fields: "*variants.calculated_price,*variants.inventory_quantity"
    })
    
    return products[0] || null
  },
  ["producto-detalle"],
  {
    revalidate: 3600, // 1 hora
    tags: ["productos"],
  }
)

export async function buscarProductos(query: string) {
  const { products } = await clienteMedusa.store.product.list({
    q: query,
    limit: 10,
  })
  
  return products
}
Servicio de Carrito
typescript// src/lib/medusa/carrito.ts
import { clienteMedusa } from "./cliente"
import { cookies } from "next/headers"
import type { StoreCart } from "@medusajs/types"

const COOKIE_CARRITO = "carrito_id"

export async function obtenerOCrearCarrito(): Promise<StoreCart> {
  const cookieStore = await cookies()
  const carritoId = cookieStore.get(COOKIE_CARRITO)?.value

  if (carritoId) {
    try {
      const { cart } = await clienteMedusa.store.cart.retrieve(carritoId)
      return cart
    } catch (error) {
      // Si el carrito no existe o expiró, crear uno nuevo
      console.error("Error al obtener carrito:", error)
    }
  }

  // Crear nuevo carrito
  const { cart } = await clienteMedusa.store.cart.create({
    region_id: await obtenerRegionPorDefecto(),
  })
  
  cookieStore.set(COOKIE_CARRITO, cart.id, {
    maxAge: 60 * 60 * 24 * 30, // 30 días
    httpOnly: true,
    sameSite: "lax",
    secure: process.env.NODE_ENV === "production",
  })

  return cart
}

async function obtenerRegionPorDefecto(): Promise<string> {
  const { regions } = await clienteMedusa.store.region.list()
  return regions[0]?.id || ""
}

export async function agregarItemAlCarrito(
  variantId: string,
  cantidad: number = 1
): Promise<StoreCart> {
  const carrito = await obtenerOCrearCarrito()

  const { cart } = await clienteMedusa.store.cart.lineItem.create(
    carrito.id,
    {
      variant_id: variantId,
      quantity: cantidad,
    }
  )

  return cart
}

export async function actualizarItemCarrito(
  carritoId: string,
  lineItemId: string,
  cantidad: number
): Promise<StoreCart> {
  const { cart } = await clienteMedusa.store.cart.lineItem.update(
    carritoId,
    lineItemId,
    { quantity: cantidad }
  )

  return cart
}

export async function eliminarItemCarrito(
  carritoId: string,
  lineItemId: string
): Promise<StoreCart> {
  const { cart } = await clienteMedusa.store.cart.lineItem.delete(
    carritoId,
    lineItemId
  )

  return cart
}
Servicio de Checkout
typescript// src/lib/medusa/checkout.ts
import { clienteMedusa } from "./cliente"
import type { StoreCart } from "@medusajs/types"

export async function agregarDireccionEnvio(
  carritoId: string,
  direccion: {
    nombre: string
    apellido: string
    direccion1: string
    direccion2?: string
    ciudad: string
    codigoPostal: string
    provincia: string
    pais: string
    telefono?: string
  }
): Promise<StoreCart> {
  const { cart } = await clienteMedusa.store.cart.update(carritoId, {
    shipping_address: {
      first_name: direccion.nombre,
      last_name: direccion.apellido,
      address_1: direccion.direccion1,
      address_2: direccion.direccion2,
      city: direccion.ciudad,
      postal_code: direccion.codigoPostal,
      province: direccion.provincia,
      country_code: direccion.pais,
      phone: direccion.telefono,
    },
  })

  return cart
}

export async function agregarEmailCarrito(
  carritoId: string,
  email: string
): Promise<StoreCart> {
  const { cart } = await clienteMedusa.store.cart.update(carritoId, {
    email,
  })

  return cart
}

export async function seleccionarOpcionEnvio(
  carritoId: string,
  opcionId: string
): Promise<StoreCart> {
  const { cart } = await clienteMedusa.store.cart.shippingMethod.create(
    carritoId,
    {
      option_id: opcionId,
    }
  )

  return cart
}

export async function completarCarrito(
  carritoId: string
): Promise<{ pedidoId: string }> {
  const { order } = await clienteMedusa.store.cart.complete(carritoId)
  
  return { pedidoId: order.id }
}
Server Actions
Acciones de Carrito
typescript// src/acciones/carrito.ts
"use server"

import { revalidatePath } from "next/cache"
import {
  agregarItemAlCarrito,
  actualizarItemCarrito,
  eliminarItemCarrito,
} from "@/lib/medusa/carrito"

export async function agregarAlCarritoAccion(
  variantId: string,
  cantidad: number = 1
) {
  try {
    await agregarItemAlCarrito(variantId, cantidad)
    revalidatePath("/carrito")
    return { exito: true }
  } catch (error) {
    console.error("Error al agregar al carrito:", error)
    return {
      exito: false,
      mensaje: "No se pudo agregar el producto al carrito",
    }
  }
}

export async function actualizarCantidadAccion(
  carritoId: string,
  lineItemId: string,
  cantidad: number
) {
  try {
    await actualizarItemCarrito(carritoId, lineItemId, cantidad)
    revalidatePath("/carrito")
    return { exito: true }
  } catch (error) {
    console.error("Error al actualizar cantidad:", error)
    return {
      exito: false,
      mensaje: "No se pudo actualizar la cantidad",
    }
  }
}

export async function eliminarItemAccion(
  carritoId: string,
  lineItemId: string
) {
  try {
    await eliminarItemCarrito(carritoId, lineItemId)
    revalidatePath("/carrito")
    return { exito: true }
  } catch (error) {
    console.error("Error al eliminar item:", error)
    return {
      exito: false,
      mensaje: "No se pudo eliminar el producto",
    }
  }
}
Acciones de Checkout
typescript// src/acciones/checkout.ts
"use server"

import { redirect } from "next/navigation"
import {
  agregarDireccionEnvio,
  agregarEmailCarrito,
  seleccionarOpcionEnvio,
  completarCarrito,
} from "@/lib/medusa/checkout"

export async function enviarDireccionAccion(
  carritoId: string,
  formData: FormData
) {
  const direccion = {
    nombre: formData.get("nombre") as string,
    apellido: formData.get("apellido") as string,
    direccion1: formData.get("direccion1") as string,
    direccion2: formData.get("direccion2") as string,
    ciudad: formData.get("ciudad") as string,
    codigoPostal: formData.get("codigoPostal") as string,
    provincia: formData.get("provincia") as string,
    pais: formData.get("pais") as string,
    telefono: formData.get("telefono") as string,
  }

  try {
    await agregarDireccionEnvio(carritoId, direccion)
    redirect("/checkout/envio")
  } catch (error) {
    console.error("Error al guardar dirección:", error)
    return {
      exito: false,
      mensaje: "No se pudo guardar la dirección",
    }
  }
}

export async function completarPedidoAccion(carritoId: string) {
  try {
    const { pedidoId } = await completarCarrito(carritoId)
    redirect(`/pedido/confirmacion/${pedidoId}`)
  } catch (error) {
    console.error("Error al completar pedido:", error)
    return {
      exito: false,
      mensaje: "No se pudo completar el pedido",
    }
  }
}
Autenticación de Clientes
typescript// src/lib/medusa/auth.ts
import { clienteMedusa } from "./cliente"
import { cookies } from "next/headers"

const COOKIE_AUTH = "auth_token"

export async function iniciarSesion(email: string, password: string) {
  try {
    const { token } = await clienteMedusa.auth.authenticate({
      email,
      password,
    })

    const cookieStore = await cookies()
    cookieStore.set(COOKIE_AUTH, token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax",
      maxAge: 60 * 60 * 24 * 7, // 7 días
    })

    return { exito: true }
  } catch (error) {
    return {
      exito: false,
      mensaje: "Credenciales inválidas",
    }
  }
}

export async function obtenerClienteActual() {
  const cookieStore = await cookies()
  const token = cookieStore.get(COOKIE_AUTH)?.value

  if (!token) return null

  try {
    const { customer } = await clienteMedusa.store.customer.retrieve({
      headers: { Authorization: `Bearer ${token}` },
    })
    return customer
  } catch (error) {
    return null
  }
}

export async function cerrarSesion() {
  const cookieStore = await cookies()
  cookieStore.delete(COOKIE_AUTH)
}
Webhooks de Medusa
Endpoint de Webhook
typescript// src/app/api/webhooks/medusa/route.ts
import { NextRequest } from "next/server"
import { revalidateTag } from "next/cache"

export async function POST(req: NextRequest) {
  const body = await req.json()
  const { event, data } = body

  // Validar firma del webhook (producción)
  const firma = req.headers.get("x-medusa-signature")
  if (!validarFirma(firma, body)) {
    return Response.json({ error: "Firma inválida" }, { status: 401 })
  }

  // Manejar eventos
  switch (event) {
    case "product.created":
    case "product.updated":
      await revalidateTag("productos")
      break

    case "order.placed":
      await procesarNuevoPedido(data.id)
      break

    default:
      console.log(`Evento no manejado: ${event}`)
  }

  return Response.json({ recibido: true })
}

function validarFirma(firma: string | null, body: unknown): boolean {
  // Implementar validación según docs de Medusa
  return true
}

async function procesarNuevoPedido(pedidoId: string) {
  // Lógica adicional al recibir nuevo pedido
  console.log(`Nuevo pedido: ${pedidoId}`)
}
Variables de Entorno
bash# .env.local (Frontend)
NEXT_PUBLIC_MEDUSA_BACKEND_URL=http://localhost:9000
NEXT_PUBLIC_MEDUSA_PUBLISHABLE_KEY=pk_xxx
NEXT_PUBLIC_BASE_URL=http://localhost:3000

# .env (Backend)
DATABASE_URL=postgresql://user:password@localhost:5432/medusa
MEDUSA_ADMIN_CORS=http://localhost:7001
STORE_CORS=http://localhost:3000
Testing de Integración
typescript// __tests__/integracion/productos.test.ts
import { listarProductos, obtenerProductoPorHandle } from "@/lib/medusa/productos"

describe("Integración Medusa - Productos", () => {
  it("debe listar productos correctamente", async () => {
    const { productos, total } = await listarProductos()

    expect(Array.isArray(productos)).toBe(true)
    expect(total).toBeGreaterThanOrEqual(0)
  })

  it("debe obtener un producto por handle", async () => {
    const producto = await obtenerProductoPorHandle("producto-test")

    if (producto) {
      expect(producto).toHaveProperty("id")
      expect(producto).toHaveProperty("title")
      expect(producto.handle).toBe("producto-test")
    }
  })
})